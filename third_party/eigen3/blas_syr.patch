diff --git a/Eigen/Core b/Eigen/Core
index bb8ad464d..b1f17e3f7 100644
--- a/Eigen/Core
+++ b/Eigen/Core
@@ -345,6 +345,7 @@ using std::ptrdiff_t;
 #include "src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h"
 #include "src/Core/products/SelfadjointMatrixMatrix_BLAS.h"
 #include "src/Core/products/SelfadjointMatrixVector_BLAS.h"
+#include "src/Core/products/SelfadjointProduct_BLAS.h"
 #include "src/Core/products/TriangularMatrixMatrix_BLAS.h"
 #include "src/Core/products/TriangularMatrixVector_BLAS.h"
 #include "src/Core/products/TriangularSolverMatrix_BLAS.h"
diff --git a/Eigen/src/Core/ProductEvaluators.h b/Eigen/src/Core/ProductEvaluators.h
index d53dc30a3..acfbc3ce3 100644
--- a/Eigen/src/Core/ProductEvaluators.h
+++ b/Eigen/src/Core/ProductEvaluators.h
@@ -797,7 +797,11 @@ struct generic_product_impl<Lhs,Rhs,SelfAdjointShape,DenseShape,ProductTag>
   static EIGEN_DEVICE_FUNC
   void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)
   {
-    selfadjoint_product_impl<typename Lhs::MatrixType,Lhs::Mode,false,Rhs,0,Rhs::IsVectorAtCompileTime>::run(dst, lhs.nestedExpression(), rhs, alpha);
+	  if (rhs.cols() ==1 || rhs.rows() == 1){
+	    selfadjoint_product_impl<typename Lhs::MatrixType,Lhs::Mode,false,Rhs,0,true>::run(dst, lhs.nestedExpression(), rhs, alpha);
+	  }
+	  else
+	    selfadjoint_product_impl<typename Lhs::MatrixType,Lhs::Mode,false,Rhs,0,false>::run(dst, lhs.nestedExpression(), rhs, alpha);
   }
 };
 
diff --git a/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h b/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h
index 9a650ec23..444216c2d 100644
--- a/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h
+++ b/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h
@@ -68,8 +68,8 @@ struct general_matrix_matrix_triangular_product<Index,Scalar,LhsStorageOrder,Con
 EIGEN_BLAS_RANKUPDATE_SPECIALIZE(double)
 EIGEN_BLAS_RANKUPDATE_SPECIALIZE(float)
 // TODO handle complex cases
-// EIGEN_BLAS_RANKUPDATE_SPECIALIZE(dcomplex)
-// EIGEN_BLAS_RANKUPDATE_SPECIALIZE(scomplex)
+EIGEN_BLAS_RANKUPDATE_SPECIALIZE(dcomplex)
+EIGEN_BLAS_RANKUPDATE_SPECIALIZE(scomplex)
 
 // SYRK for float/double
 #define EIGEN_BLAS_RANKUPDATE_R(EIGTYPE, BLASTYPE, BLASFUNC) \
@@ -128,14 +128,16 @@ struct general_matrix_matrix_rankupdate<Index,EIGTYPE,AStorageOrder,ConjugateA,C
 #ifdef EIGEN_USE_MKL
 EIGEN_BLAS_RANKUPDATE_R(double, double, dsyrk)
 EIGEN_BLAS_RANKUPDATE_R(float,  float,  ssyrk)
+EIGEN_BLAS_RANKUPDATE_C(dcomplex, MKL_Complex16, double, zherk)
+EIGEN_BLAS_RANKUPDATE_C(scomplex, MKL_Complex8,  float, cherk)
 #else
 EIGEN_BLAS_RANKUPDATE_R(double, double, dsyrk_)
 EIGEN_BLAS_RANKUPDATE_R(float,  float,  ssyrk_)
+EIGEN_BLAS_RANKUPDATE_C(dcomplex, dcomplex, double, zherk_)
+EIGEN_BLAS_RANKUPDATE_C(scomplex, scomplex,  float, cherk_)
 #endif
 
 // TODO hanlde complex cases
-// EIGEN_BLAS_RANKUPDATE_C(dcomplex, double, double, zherk_)
-// EIGEN_BLAS_RANKUPDATE_C(scomplex, float,  float, cherk_)
 
 
 } // end namespace internal
diff --git a/Eigen/src/Core/products/SelfadjointMatrixVector.h b/Eigen/src/Core/products/SelfadjointMatrixVector.h
index d38fd72b2..91623741e 100644
--- a/Eigen/src/Core/products/SelfadjointMatrixVector.h
+++ b/Eigen/src/Core/products/SelfadjointMatrixVector.h
@@ -220,7 +220,7 @@ struct selfadjoint_product_impl<Lhs,LhsMode,false,Rhs,0,true>
       Index size = rhs.size();
       EIGEN_DENSE_STORAGE_CTOR_PLUGIN
       #endif
-      Map<typename ActualRhsTypeCleaned::PlainObject>(actualRhsPtr, rhs.size()) = rhs;
+      //Map<typename ActualRhsTypeCleaned::PlainObject>(actualRhsPtr, rhs.size()) = rhs;
     }
       
       
diff --git a/Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h b/Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h
index 1238345e3..dafea87cf 100644
--- a/Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h
+++ b/Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h
@@ -53,17 +53,9 @@ struct selfadjoint_matrix_vector_product<Scalar,Index,StorageOrder,UpLo,Conjugat
 static void run( \
   Index size, const Scalar*  lhs, Index lhsStride, \
   const Scalar* _rhs, Scalar* res, Scalar alpha) { \
-    enum {\
-      IsColMajor = StorageOrder==ColMajor \
-    }; \
-    if (IsColMajor == ConjugateLhs) {\
-      selfadjoint_matrix_vector_product<Scalar,Index,StorageOrder,UpLo,ConjugateLhs,ConjugateRhs,BuiltIn>::run( \
-        size, lhs, lhsStride, _rhs, res, alpha);  \
-    } else {\
       selfadjoint_matrix_vector_product_symv<Scalar,Index,StorageOrder,UpLo,ConjugateLhs,ConjugateRhs>::run( \
         size, lhs, lhsStride, _rhs, res, alpha);  \
     }\
-  } \
 }; \
 
 EIGEN_BLAS_SYMV_SPECIALIZE(double)
diff --git a/Eigen/src/Core/products/SelfadjointProduct.h b/Eigen/src/Core/products/SelfadjointProduct.h
index 61e8894e7..d291391c9 100644
--- a/Eigen/src/Core/products/SelfadjointProduct.h
+++ b/Eigen/src/Core/products/SelfadjointProduct.h
@@ -44,7 +44,7 @@ struct selfadjoint_rank1_update<Scalar,Index,RowMajor,UpLo,ConjLhs,ConjRhs>
   }
 };
 
-template<typename MatrixType, typename OtherType, int UpLo, bool OtherIsVector = OtherType::IsVectorAtCompileTime>
+template<typename MatrixType, typename OtherType, int UpLo, bool OtherIsVector>
 struct selfadjoint_product_selector;
 
 template<typename MatrixType, typename OtherType, int UpLo>
@@ -68,9 +68,10 @@ struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,true>
 
     ei_declare_aligned_stack_constructed_variable(Scalar, actualOtherPtr, other.size(),
       (UseOtherDirectly ? const_cast<Scalar*>(actualOther.data()) : static_other.data()));
-      
-    if(!UseOtherDirectly)
-      Map<typename _ActualOtherType::PlainObject>(actualOtherPtr, actualOther.size()) = actualOther;
+    
+    //TODO: What is this used for???
+    //if(!UseOtherDirectly)
+    //  Map<typename _ActualOtherType::PlainObject>(actualOtherPtr, actualOther.size()) = actualOther;
     
     selfadjoint_rank1_update<Scalar,Index,StorageOrder,UpLo,
                               OtherBlasTraits::NeedToConjugate  && NumTraits<Scalar>::IsComplex,
@@ -123,7 +124,12 @@ template<typename DerivedU>
 EIGEN_DEVICE_FUNC SelfAdjointView<MatrixType,UpLo>& SelfAdjointView<MatrixType,UpLo>
 ::rankUpdate(const MatrixBase<DerivedU>& u, const Scalar& alpha)
 {
-  selfadjoint_product_selector<MatrixType,DerivedU,UpLo>::run(_expression().const_cast_derived(), u.derived(), alpha);
+	if (u.cols() == 1 || u.rows() == 1){
+		selfadjoint_product_selector<MatrixType,DerivedU,UpLo,true>::run(_expression().const_cast_derived(), u.derived(), alpha);
+	}
+	else{
+		selfadjoint_product_selector<MatrixType,DerivedU,UpLo,false>::run(_expression().const_cast_derived(), u.derived(), alpha);
+	}
 
   return *this;
 }
diff --git a/Eigen/src/Core/products/SelfadjointProduct_BLAS.h b/Eigen/src/Core/products/SelfadjointProduct_BLAS.h
new file mode 100644
index 000000000..93fbfad97
--- /dev/null
+++ b/Eigen/src/Core/products/SelfadjointProduct_BLAS.h
@@ -0,0 +1,88 @@
+#ifndef EIGEN_SELFADJOINT_PRODUCT_BLAS_H
+#define EIGEN_SELFADJOINT_PRODUCT_BLAS_H
+
+namespace Eigen { 
+
+#define EIGEN_BLAS_HER_SPECIALIZATION(EIGTYPE,EIGREALTYPE,BLASTYPE,BLASFUNC) \
+template<typename Index, int UpLo, bool ConjLhs, bool ConjRhs> \
+struct selfadjoint_rank1_update<EIGTYPE,Index,ColMajor,UpLo,ConjLhs,ConjRhs> \
+{ \
+  static void run(Index size, EIGTYPE* mat, Index stride, const EIGTYPE* vecX, const EIGTYPE* vecY, const EIGTYPE& alpha) \
+  { \
+    char uplo = UpLo == Lower ? 'L':'U'; \
+    BlasIndex n = internal::convert_index<BlasIndex>(size), lda=internal::convert_index<BlasIndex>(stride), incx=1, incy=1; \
+    typedef Matrix<EIGTYPE, Dynamic, Dynamic, RowMajor> MatrixType; \
+    MatrixType a; \
+    const EIGTYPE* a_ptr; \
+    if (!ConjRhs) { \
+      Map<const MatrixType, 0, OuterStride<> > mapA(vecX,n,1,OuterStride<>(incx)); \
+      a = mapA.conjugate(); \
+      a_ptr = a.data(); \
+    } else a_ptr=vecX; \
+    BLASFUNC(&uplo,&n, (const EIGREALTYPE*)&numext::real_ref(alpha), (const BLASTYPE*) a_ptr, &incx,(BLASTYPE*)mat,(const BlasIndex*) &lda); \
+  } \
+}; \
+template<typename Index, int UpLo, bool ConjLhs, bool ConjRhs> \
+struct selfadjoint_rank1_update<EIGTYPE,Index,RowMajor,UpLo,ConjLhs,ConjRhs> \
+{ \
+  static void run(Index size, EIGTYPE* mat, Index stride, const EIGTYPE* vecX, const EIGTYPE* vecY, const EIGTYPE& alpha) \
+  { \
+    char uplo = UpLo == Lower ? 'U':'L'; \
+    BlasIndex n = internal::convert_index<BlasIndex>(size), lda=internal::convert_index<BlasIndex>(stride), incx=1, incy=1; \
+    typedef Matrix<EIGTYPE, Dynamic, Dynamic, RowMajor> MatrixType; \
+    MatrixType a; \
+    const EIGTYPE* a_ptr; \
+    if (ConjRhs) { \
+      Map<const MatrixType, 0, OuterStride<> > mapA(vecX,n,1,OuterStride<>(incx)); \
+      a = mapA.conjugate(); \
+      a_ptr = a.data(); \
+    } else a_ptr=vecX; \
+    BLASFUNC(&uplo,&n, (const EIGREALTYPE*)&numext::real_ref(alpha), (const BLASTYPE*) a_ptr, &incx,(BLASTYPE*)mat,(const BlasIndex*) &lda); \
+  } \
+};
+
+#ifdef EIGEN_USE_MKL
+EIGEN_BLAS_HER_SPECIALIZATION(double, double,  double, dsyr)
+EIGEN_BLAS_HER_SPECIALIZATION(float,  float,  float,  ssyr)
+EIGEN_BLAS_HER_SPECIALIZATION(dcomplex, double, MKL_Complex16, zher)
+EIGEN_BLAS_HER_SPECIALIZATION(scomplex, float,MKL_Complex8,  cher)
+#else
+EIGEN_BLAS_HER_SPECIALIZATION(double, double,  double, dsyr_)
+EIGEN_BLAS_HER_SPECIALIZATION(float, float,   float,  ssyr_)
+EIGEN_BLAS_HER_SPECIALIZATION(dcomplex, double,dcomplex, zher_)
+EIGEN_BLAS_HER_SPECIALIZATION(scomplex, float, scomplex,  cher_)
+#endif
+
+
+//#define EIGEN_BLAS_HERK_SPECIALIZATION(EIGTYPE,EIGREALTYPE,BLASTYPE,BLASFUNC) \
+//template<typename Index, int UpLo, int StorageOrder, int MaxColsAtCompileTime, int InnerStrideAtCompileTime, \
+//	int OtherStorageOrder, int OtherMaxColsAtCompileTime, bool ConjLhs, bool ConjRhs> \
+//struct selfadjoint_rank_k_update<EIGTYPE,Index,UpLo,StorageOrder, MaxColsAtCompileTime, InnerStrideAtCompileTime, \
+//OtherStorageOrder, OtherMaxColsAtCompileTime, ConjLhs,ConjRhs> \
+//{ \
+//    static void EIGEN_STRONG_INLINE run(Index size, Index depth, EIGTYPE* mat, Index stride, const EIGTYPE* other, Index otherStride, const EIGTYPE& alpha)\
+//  { \
+//    char uplo = UpLo == Lower ? 'L':'U'; \
+//    char trans=((StorageOrder==RowMajor) ? 'C':'N');\
+//    EIGREALTYPE beta_ = 1.0; \
+//    BlasIndex lda= internal::convert_index<BlasIndex>(otherStride), ldc= internal::convert_index<BlasIndex>(stride), \
+//	  n= internal::convert_index<BlasIndex>(size), k= internal::convert_index<BlasIndex>(depth); \
+//    BLASFUNC(&uplo, &trans, &n, &k, (const EIGREALTYPE*) &numext::real_ref(alpha), (BLASTYPE*)other, &lda, &beta_, (BLASTYPE*) mat, &ldc); \
+//  } \
+//};
+//
+//#ifdef EIGEN_USE_MKL
+////EIGEN_BLAS_HERK_SPECIALIZATION(double, double,  double, dsyr)
+////EIGEN_BLAS_HERK_SPECIALIZATION(float,  float,  float,  ssyr)
+//EIGEN_BLAS_HERK_SPECIALIZATION(dcomplex, double, MKL_Complex16, zherk)
+//EIGEN_BLAS_HERK_SPECIALIZATION(scomplex, float,MKL_Complex8,  cherk)
+//#else
+////EIGEN_BLAS_HERK_SPECIALIZATION(double, double,  double, dsyr_)
+////EIGEN_BLAS_HERK_SPECIALIZATION(float, float,   float,  ssyr_)
+//EIGEN_BLAS_HERK_SPECIALIZATION(dcomplex, double,double, zherk_)
+//EIGEN_BLAS_HERK_SPECIALIZATION(scomplex, float, float,  cherk_)
+//#endif
+
+} // end namespace Eigen
+
+#endif // EIGEN_SELFADJOINT_PRODUCT_H
